package schema

// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "net/http"
    "context"
    "github.com/Azure/go-autorest/tracing"
)

// ConversationsClient is the the Bot Connector REST API allows your bot to send and receive messages to channels
// configured in the
// [Bot Framework Developer Portal](https://dev.botframework.com). The Connector service uses industry-standard REST
// and JSON over HTTPS.
//
// Client libraries for this REST API are available. See below for a list.
//
// Many bots will use both the Bot Connector REST API and the associated [Bot State REST API](/en-us/restapi/state).
// The
// Bot State REST API allows a bot to store and retrieve state associated with users and conversations.
//
// Authentication for both the Bot Connector and Bot State REST APIs is accomplished with JWT Bearer tokens, and is
// described in detail in the [Connector Authentication](/en-us/restapi/authentication) document.
//
// # Client Libraries for the Bot Connector REST API
//
// * [Bot Builder for C#](/en-us/csharp/builder/sdkreference/)
// * [Bot Builder for Node.js](/en-us/node/builder/overview/)
// * Generate your own from the [Connector API Swagger
// file](https://raw.githubusercontent.com/Microsoft/BotBuilder/master/CSharp/Library/Microsoft.Bot.Connector.Shared/Swagger/ConnectorAPI.json)
//
// Â© 2016 Microsoft
type ConversationsClient struct {
    BaseClient
}
// NewConversationsClient creates an instance of the ConversationsClient client.
func NewConversationsClient() ConversationsClient {
    return NewConversationsClientWithBaseURI(DefaultBaseURI, )
}

// NewConversationsClientWithBaseURI creates an instance of the ConversationsClient client.
    func NewConversationsClientWithBaseURI(baseURI string, ) ConversationsClient {
        return ConversationsClient{ NewWithBaseURI(baseURI, )}
    }

// CreateConversationMethod create a new Conversation.
//
// POST to this method with a
// * Bot being the bot creating the conversation
// * IsGroup set to true if this is not a direct message (default is false)
// * Array containing the members to include in the conversation
//
// The return value is a ResourceResponse which contains a conversation id which is suitable for use
// in the message payload and REST API uris.
//
// Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do
// that would be:
//
// ```
// var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members =
// new ChannelAccount[] { new ChannelAccount("user1") } );
// await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;
//
// ```
    // Parameters:
        // parameters - parameters to create the conversation from
func (client ConversationsClient) CreateConversationMethod(ctx context.Context, parameters ConversationParametersType) (result ConversationResourceResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversationsClient.CreateConversationMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        req, err := client.CreateConversationMethodPreparer(ctx, parameters)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".ConversationsClient", "CreateConversationMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.CreateConversationMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "CreateConversationMethod", resp, "Failure sending request")
            return
            }

            result, err = client.CreateConversationMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "CreateConversationMethod", resp, "Failure responding to request")
            }

    return
    }

    // CreateConversationMethodPreparer prepares the CreateConversationMethod request.
    func (client ConversationsClient) CreateConversationMethodPreparer(ctx context.Context, parameters ConversationParametersType) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/v3/conversations"),
    autorest.WithJSON(parameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateConversationMethodSender sends the CreateConversationMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client ConversationsClient) CreateConversationMethodSender(req *http.Request) (*http.Response, error) {
        sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            return autorest.SendWithSender(client, req, sd...)
            }

// CreateConversationMethodResponder handles the response to the CreateConversationMethod request. The method always
// closes the http.Response Body.
func (client ConversationsClient) CreateConversationMethodResponder(resp *http.Response) (result ConversationResourceResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusAccepted),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// DeleteActivityMethod delete an existing activity.
//
// Some channels allow you to delete an existing activity, and if successful this method will remove the specified
// activity.
    // Parameters:
        // conversationID - conversation ID
        // activityID - activityId to delete
func (client ConversationsClient) DeleteActivityMethod(ctx context.Context, conversationID string, activityID string) (result autorest.Response, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversationsClient.DeleteActivityMethod")
        defer func() {
            sc := -1
            if result.Response != nil {
                sc = result.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        req, err := client.DeleteActivityMethodPreparer(ctx, conversationID, activityID)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".ConversationsClient", "DeleteActivityMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.DeleteActivityMethodSender(req)
            if err != nil {
            result.Response = resp
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "DeleteActivityMethod", resp, "Failure sending request")
            return
            }

            result, err = client.DeleteActivityMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "DeleteActivityMethod", resp, "Failure responding to request")
            }

    return
    }

    // DeleteActivityMethodPreparer prepares the DeleteActivityMethod request.
    func (client ConversationsClient) DeleteActivityMethodPreparer(ctx context.Context, conversationID string, activityID string) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "activityId": autorest.Encode("path",activityID),
            "conversationId": autorest.Encode("path",conversationID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsDelete(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/v3/conversations/{conversationId}/activities/{activityId}",pathParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteActivityMethodSender sends the DeleteActivityMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client ConversationsClient) DeleteActivityMethodSender(req *http.Request) (*http.Response, error) {
        sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            return autorest.SendWithSender(client, req, sd...)
            }

// DeleteActivityMethodResponder handles the response to the DeleteActivityMethod request. The method always
// closes the http.Response Body.
func (client ConversationsClient) DeleteActivityMethodResponder(resp *http.Response) (result autorest.Response, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted),
    autorest.ByClosing())
    result.Response = resp
        return
    }

// DeleteConversationMemberMethod deletes a member from a conversation.
//
// This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation.
// If that member was the last member
// of the conversation, the conversation will also be deleted.
    // Parameters:
        // conversationID - conversation ID
        // memberID - ID of the member to delete from this conversation
func (client ConversationsClient) DeleteConversationMemberMethod(ctx context.Context, conversationID string, memberID string) (result autorest.Response, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversationsClient.DeleteConversationMemberMethod")
        defer func() {
            sc := -1
            if result.Response != nil {
                sc = result.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        req, err := client.DeleteConversationMemberMethodPreparer(ctx, conversationID, memberID)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".ConversationsClient", "DeleteConversationMemberMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.DeleteConversationMemberMethodSender(req)
            if err != nil {
            result.Response = resp
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "DeleteConversationMemberMethod", resp, "Failure sending request")
            return
            }

            result, err = client.DeleteConversationMemberMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "DeleteConversationMemberMethod", resp, "Failure responding to request")
            }

    return
    }

    // DeleteConversationMemberMethodPreparer prepares the DeleteConversationMemberMethod request.
    func (client ConversationsClient) DeleteConversationMemberMethodPreparer(ctx context.Context, conversationID string, memberID string) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "conversationId": autorest.Encode("path",conversationID),
            "memberId": autorest.Encode("path",memberID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsDelete(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/v3/conversations/{conversationId}/members/{memberId}",pathParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteConversationMemberMethodSender sends the DeleteConversationMemberMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client ConversationsClient) DeleteConversationMemberMethodSender(req *http.Request) (*http.Response, error) {
        sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            return autorest.SendWithSender(client, req, sd...)
            }

// DeleteConversationMemberMethodResponder handles the response to the DeleteConversationMemberMethod request. The method always
// closes the http.Response Body.
func (client ConversationsClient) DeleteConversationMemberMethodResponder(resp *http.Response) (result autorest.Response, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent),
    autorest.ByClosing())
    result.Response = resp
        return
    }

// GetActivityMembersMethod enumerate the members of an activity.
//
// This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the
// members of the particular activity in the conversation.
    // Parameters:
        // conversationID - conversation ID
        // activityID - activity ID
func (client ConversationsClient) GetActivityMembersMethod(ctx context.Context, conversationID string, activityID string) (result ListChannelAccountType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversationsClient.GetActivityMembersMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        req, err := client.GetActivityMembersMethodPreparer(ctx, conversationID, activityID)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".ConversationsClient", "GetActivityMembersMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.GetActivityMembersMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "GetActivityMembersMethod", resp, "Failure sending request")
            return
            }

            result, err = client.GetActivityMembersMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "GetActivityMembersMethod", resp, "Failure responding to request")
            }

    return
    }

    // GetActivityMembersMethodPreparer prepares the GetActivityMembersMethod request.
    func (client ConversationsClient) GetActivityMembersMethodPreparer(ctx context.Context, conversationID string, activityID string) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "activityId": autorest.Encode("path",activityID),
            "conversationId": autorest.Encode("path",conversationID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsGet(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/v3/conversations/{conversationId}/activities/{activityId}/members",pathParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetActivityMembersMethodSender sends the GetActivityMembersMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client ConversationsClient) GetActivityMembersMethodSender(req *http.Request) (*http.Response, error) {
        sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            return autorest.SendWithSender(client, req, sd...)
            }

// GetActivityMembersMethodResponder handles the response to the GetActivityMembersMethod request. The method always
// closes the http.Response Body.
func (client ConversationsClient) GetActivityMembersMethodResponder(resp *http.Response) (result ListChannelAccountType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result.Value),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// GetConversationMembersMethod enumerate the members of a conversation.
//
// This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the
// conversation.
    // Parameters:
        // conversationID - conversation ID
func (client ConversationsClient) GetConversationMembersMethod(ctx context.Context, conversationID string) (result ListChannelAccountType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversationsClient.GetConversationMembersMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        req, err := client.GetConversationMembersMethodPreparer(ctx, conversationID)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".ConversationsClient", "GetConversationMembersMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.GetConversationMembersMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "GetConversationMembersMethod", resp, "Failure sending request")
            return
            }

            result, err = client.GetConversationMembersMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "GetConversationMembersMethod", resp, "Failure responding to request")
            }

    return
    }

    // GetConversationMembersMethodPreparer prepares the GetConversationMembersMethod request.
    func (client ConversationsClient) GetConversationMembersMethodPreparer(ctx context.Context, conversationID string) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "conversationId": autorest.Encode("path",conversationID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsGet(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/v3/conversations/{conversationId}/members",pathParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetConversationMembersMethodSender sends the GetConversationMembersMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client ConversationsClient) GetConversationMembersMethodSender(req *http.Request) (*http.Response, error) {
        sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            return autorest.SendWithSender(client, req, sd...)
            }

// GetConversationMembersMethodResponder handles the response to the GetConversationMembersMethod request. The method always
// closes the http.Response Body.
func (client ConversationsClient) GetConversationMembersMethodResponder(resp *http.Response) (result ListChannelAccountType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result.Value),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// GetConversationPagedMembersMethod enumerate the members of a conversation one page at a time.
//
// This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a
// PagedMembersResult, which contains an array
// of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get
// more values.
//
// One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between
// channels and calls. The pageSize parameter can be used as
// a suggestion. If there are no additional results the response will not contain a continuation token. If there are no
// members in the conversation the Members will be empty or not present in the response.
//
// A response to a request that has a continuation token from a prior request may rarely return members from a previous
// request.
    // Parameters:
        // conversationID - conversation ID
        // pageSize - suggested page size
        // continuationToken - continuation Token
func (client ConversationsClient) GetConversationPagedMembersMethod(ctx context.Context, conversationID string, pageSize *int32, continuationToken string) (result PagedMembersResultType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversationsClient.GetConversationPagedMembersMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        req, err := client.GetConversationPagedMembersMethodPreparer(ctx, conversationID, pageSize, continuationToken)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".ConversationsClient", "GetConversationPagedMembersMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.GetConversationPagedMembersMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "GetConversationPagedMembersMethod", resp, "Failure sending request")
            return
            }

            result, err = client.GetConversationPagedMembersMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "GetConversationPagedMembersMethod", resp, "Failure responding to request")
            }

    return
    }

    // GetConversationPagedMembersMethodPreparer prepares the GetConversationPagedMembersMethod request.
    func (client ConversationsClient) GetConversationPagedMembersMethodPreparer(ctx context.Context, conversationID string, pageSize *int32, continuationToken string) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "conversationId": autorest.Encode("path",conversationID),
            }

                    queryParameters := map[string]interface{} {
        }
            if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
            }
            if len(continuationToken) > 0 {
            queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
            }

        preparer := autorest.CreatePreparer(
    autorest.AsGet(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/v3/conversations/{conversationId}/pagedmembers",pathParameters),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetConversationPagedMembersMethodSender sends the GetConversationPagedMembersMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client ConversationsClient) GetConversationPagedMembersMethodSender(req *http.Request) (*http.Response, error) {
        sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            return autorest.SendWithSender(client, req, sd...)
            }

// GetConversationPagedMembersMethodResponder handles the response to the GetConversationPagedMembersMethod request. The method always
// closes the http.Response Body.
func (client ConversationsClient) GetConversationPagedMembersMethodResponder(resp *http.Response) (result PagedMembersResultType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// GetConversationsMethod list the Conversations in which this bot has participated.
//
// GET from this method with a skip token
//
// The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the
// skip token is not empty, then
// there are further values to be returned. Call this method again with the returned token to get more values.
//
// Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe
// the members of the conversation.
    // Parameters:
        // continuationToken - skip or continuation token
func (client ConversationsClient) GetConversationsMethod(ctx context.Context, continuationToken string) (result ConversationsResultType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversationsClient.GetConversationsMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        req, err := client.GetConversationsMethodPreparer(ctx, continuationToken)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".ConversationsClient", "GetConversationsMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.GetConversationsMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "GetConversationsMethod", resp, "Failure sending request")
            return
            }

            result, err = client.GetConversationsMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "GetConversationsMethod", resp, "Failure responding to request")
            }

    return
    }

    // GetConversationsMethodPreparer prepares the GetConversationsMethod request.
    func (client ConversationsClient) GetConversationsMethodPreparer(ctx context.Context, continuationToken string) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        }
            if len(continuationToken) > 0 {
            queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
            }

        preparer := autorest.CreatePreparer(
    autorest.AsGet(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/v3/conversations"),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetConversationsMethodSender sends the GetConversationsMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client ConversationsClient) GetConversationsMethodSender(req *http.Request) (*http.Response, error) {
        sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            return autorest.SendWithSender(client, req, sd...)
            }

// GetConversationsMethodResponder handles the response to the GetConversationsMethod request. The method always
// closes the http.Response Body.
func (client ConversationsClient) GetConversationsMethodResponder(resp *http.Response) (result ConversationsResultType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// ReplyToActivityMethod this method allows you to reply to an activity.
//
// This is slightly different from SendToConversation().
// * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the
// timestamp or semantics of the channel.
// * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel
// supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
//
// Use ReplyToActivity when replying to a specific activity in the conversation.
//
// Use SendToConversation in all other cases.
    // Parameters:
        // conversationID - conversation ID
        // activityID - activityId the reply is to (OPTIONAL)
        // activity - activity to send
func (client ConversationsClient) ReplyToActivityMethod(ctx context.Context, conversationID string, activityID string, activity ActivityType) (result ResourceResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversationsClient.ReplyToActivityMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        req, err := client.ReplyToActivityMethodPreparer(ctx, conversationID, activityID, activity)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".ConversationsClient", "ReplyToActivityMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.ReplyToActivityMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "ReplyToActivityMethod", resp, "Failure sending request")
            return
            }

            result, err = client.ReplyToActivityMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "ReplyToActivityMethod", resp, "Failure responding to request")
            }

    return
    }

    // ReplyToActivityMethodPreparer prepares the ReplyToActivityMethod request.
    func (client ConversationsClient) ReplyToActivityMethodPreparer(ctx context.Context, conversationID string, activityID string, activity ActivityType) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "activityId": autorest.Encode("path",activityID),
            "conversationId": autorest.Encode("path",conversationID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/v3/conversations/{conversationId}/activities/{activityId}",pathParameters),
    autorest.WithJSON(activity))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // ReplyToActivityMethodSender sends the ReplyToActivityMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client ConversationsClient) ReplyToActivityMethodSender(req *http.Request) (*http.Response, error) {
        sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            return autorest.SendWithSender(client, req, sd...)
            }

// ReplyToActivityMethodResponder handles the response to the ReplyToActivityMethod request. The method always
// closes the http.Response Body.
func (client ConversationsClient) ReplyToActivityMethodResponder(resp *http.Response) (result ResourceResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusAccepted),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// SendConversationHistoryMethod this method allows you to upload the historic activities to the conversation.
//
// Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the
// client to deal with duplicate activities and the timestamps are used by the client to render the activities in the
// right order.
    // Parameters:
        // conversationID - conversation ID
        // history - historic activities
func (client ConversationsClient) SendConversationHistoryMethod(ctx context.Context, conversationID string, history TranscriptType) (result ResourceResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversationsClient.SendConversationHistoryMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        req, err := client.SendConversationHistoryMethodPreparer(ctx, conversationID, history)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".ConversationsClient", "SendConversationHistoryMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.SendConversationHistoryMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "SendConversationHistoryMethod", resp, "Failure sending request")
            return
            }

            result, err = client.SendConversationHistoryMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "SendConversationHistoryMethod", resp, "Failure responding to request")
            }

    return
    }

    // SendConversationHistoryMethodPreparer prepares the SendConversationHistoryMethod request.
    func (client ConversationsClient) SendConversationHistoryMethodPreparer(ctx context.Context, conversationID string, history TranscriptType) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "conversationId": autorest.Encode("path",conversationID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/v3/conversations/{conversationId}/activities/history",pathParameters),
    autorest.WithJSON(history))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // SendConversationHistoryMethodSender sends the SendConversationHistoryMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client ConversationsClient) SendConversationHistoryMethodSender(req *http.Request) (*http.Response, error) {
        sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            return autorest.SendWithSender(client, req, sd...)
            }

// SendConversationHistoryMethodResponder handles the response to the SendConversationHistoryMethod request. The method always
// closes the http.Response Body.
func (client ConversationsClient) SendConversationHistoryMethodResponder(resp *http.Response) (result ResourceResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusAccepted),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// SendToConversationMethod this method allows you to send an activity to the end of a conversation.
//
// This is slightly different from ReplyToActivity().
// * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the
// timestamp or semantics of the channel.
// * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel
// supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
//
// Use ReplyToActivity when replying to a specific activity in the conversation.
//
// Use SendToConversation in all other cases.
    // Parameters:
        // conversationID - conversation ID
        // activity - activity to send
func (client ConversationsClient) SendToConversationMethod(ctx context.Context, conversationID string, activity ActivityType) (result ResourceResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversationsClient.SendToConversationMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        req, err := client.SendToConversationMethodPreparer(ctx, conversationID, activity)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".ConversationsClient", "SendToConversationMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.SendToConversationMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "SendToConversationMethod", resp, "Failure sending request")
            return
            }

            result, err = client.SendToConversationMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "SendToConversationMethod", resp, "Failure responding to request")
            }

    return
    }

    // SendToConversationMethodPreparer prepares the SendToConversationMethod request.
    func (client ConversationsClient) SendToConversationMethodPreparer(ctx context.Context, conversationID string, activity ActivityType) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "conversationId": autorest.Encode("path",conversationID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/v3/conversations/{conversationId}/activities",pathParameters),
    autorest.WithJSON(activity))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // SendToConversationMethodSender sends the SendToConversationMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client ConversationsClient) SendToConversationMethodSender(req *http.Request) (*http.Response, error) {
        sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            return autorest.SendWithSender(client, req, sd...)
            }

// SendToConversationMethodResponder handles the response to the SendToConversationMethod request. The method always
// closes the http.Response Body.
func (client ConversationsClient) SendToConversationMethodResponder(resp *http.Response) (result ResourceResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusAccepted),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// UpdateActivityMethod edit an existing activity.
//
// Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.
//
// For example, you can remove buttons after someone has clicked "Approve" button.
    // Parameters:
        // conversationID - conversation ID
        // activityID - activityId to update
        // activity - replacement Activity
func (client ConversationsClient) UpdateActivityMethod(ctx context.Context, conversationID string, activityID string, activity ActivityType) (result ResourceResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversationsClient.UpdateActivityMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        req, err := client.UpdateActivityMethodPreparer(ctx, conversationID, activityID, activity)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".ConversationsClient", "UpdateActivityMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.UpdateActivityMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "UpdateActivityMethod", resp, "Failure sending request")
            return
            }

            result, err = client.UpdateActivityMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "UpdateActivityMethod", resp, "Failure responding to request")
            }

    return
    }

    // UpdateActivityMethodPreparer prepares the UpdateActivityMethod request.
    func (client ConversationsClient) UpdateActivityMethodPreparer(ctx context.Context, conversationID string, activityID string, activity ActivityType) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "activityId": autorest.Encode("path",activityID),
            "conversationId": autorest.Encode("path",conversationID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPut(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/v3/conversations/{conversationId}/activities/{activityId}",pathParameters),
    autorest.WithJSON(activity))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // UpdateActivityMethodSender sends the UpdateActivityMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client ConversationsClient) UpdateActivityMethodSender(req *http.Request) (*http.Response, error) {
        sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            return autorest.SendWithSender(client, req, sd...)
            }

// UpdateActivityMethodResponder handles the response to the UpdateActivityMethod request. The method always
// closes the http.Response Body.
func (client ConversationsClient) UpdateActivityMethodResponder(resp *http.Response) (result ResourceResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusAccepted),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// UploadAttachmentMethod upload an attachment directly into a channel's blob storage.
//
// This is useful because it allows you to store data in a compliant store when dealing with enterprises.
//
// The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments
// API.
    // Parameters:
        // conversationID - conversation ID
        // attachmentUpload - attachment data
func (client ConversationsClient) UploadAttachmentMethod(ctx context.Context, conversationID string, attachmentUpload AttachmentDataType) (result ResourceResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ConversationsClient.UploadAttachmentMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        req, err := client.UploadAttachmentMethodPreparer(ctx, conversationID, attachmentUpload)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".ConversationsClient", "UploadAttachmentMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.UploadAttachmentMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "UploadAttachmentMethod", resp, "Failure sending request")
            return
            }

            result, err = client.UploadAttachmentMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".ConversationsClient", "UploadAttachmentMethod", resp, "Failure responding to request")
            }

    return
    }

    // UploadAttachmentMethodPreparer prepares the UploadAttachmentMethod request.
    func (client ConversationsClient) UploadAttachmentMethodPreparer(ctx context.Context, conversationID string, attachmentUpload AttachmentDataType) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "conversationId": autorest.Encode("path",conversationID),
            }

        preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/v3/conversations/{conversationId}/attachments",pathParameters),
    autorest.WithJSON(attachmentUpload))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // UploadAttachmentMethodSender sends the UploadAttachmentMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client ConversationsClient) UploadAttachmentMethodSender(req *http.Request) (*http.Response, error) {
        sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            return autorest.SendWithSender(client, req, sd...)
            }

// UploadAttachmentMethodResponder handles the response to the UploadAttachmentMethod request. The method always
// closes the http.Response Body.
func (client ConversationsClient) UploadAttachmentMethodResponder(resp *http.Response) (result ResourceResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusAccepted),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

